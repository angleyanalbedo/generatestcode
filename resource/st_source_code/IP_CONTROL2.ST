FUNCTION_BLOCK IP_CONTROL2

  VAR

  END_VAR


  VAR_EXTERNAL

  END_VAR


  VAR

  END_VAR

  VAR
    T_PLC_MS :	T_PLC_MS;
    IP4_TO_STRING :	IP4_TO_STRING;
    FB_IP_CONNECT :	IP_CONNECT;
    FB_IP_URCV :	IP_URCV;
    FB_IP_USEND :	IP_USEND;
  END_VAR

  VAR_INPUT
    IP :	DWORD;
    PORT :	WORD;
    TIME_OUT :	TIME;
  END_VAR


  VAR_IN_OUT
    IP_C :	oscat_IP_C;
    S_BUF :	oscat_NETWORK_BUFFER_SHORT;
    R_BUF :	oscat_NETWORK_BUFFER_SHORT;
  END_VAR

  VAR
    C_TIME :	UDINT;
    S_TIME :	UDINT;
    R_TIME :	UDINT;
    C_ENABLE :	BOOL;
    C_IP :	DWORD;
    C_PORT :	WORD;
    C_MODE :	BYTE;
    C_ERROR :	BOOL;
    C_STATUS :	INT;
    C_ID :	INT;
    C_RECONNECT :	BOOL;
    C_RECONNECT_COUNT :	INT;
    S_DONE :	BOOL;
    S_ERROR :	BOOL;
    S_STATUS :	INT;
    S_ACTIVE :	BOOL;
    R_NDR :	BOOL;
    R_ERROR :	BOOL;
    R_STATUS :	INT;
    NEW_CONNECTION :	BOOL;
    C_ENABLE_OLD :	BOOL;
    C_READY :	BOOL;
    C_READY_OLD :	BOOL;
    DELAY_STOP :	UDINT;
    DELAY :	UDINT;
    DELAY_VALUE :	UDINT;
    C :	INT;
    C2 :	INT;
    CS :	oscat_STRING50;
    TX :	UDINT;
    ERROR_TIME :	UDINT;
    ERROR_CON :	BYTE;
    ERROR_SND :	BYTE;
    ERROR_RCV :	BYTE;
  END_VAR

  T_PLC_MS();
  TX := T_PLC_MS.T_PLC_MS;

  IF (TX - DELAY < DELAY_VALUE) THEN
    IF IP_C.C_STATE <> BYTE#1 AND IP_C.C_STATE <> BYTE#254 THEN 
    RETURN;
    END_IF;
  END_IF;
  DELAY := TX;

  IF C_ENABLE AND DELAY_VALUE > UDINT#00 THEN
    IF (TX - DELAY_STOP > UDINT#1000) THEN 
      DELAY_VALUE := UDINT#00;

    END_IF;
  ELSE
    DELAY_STOP := TX;  
  END_IF;

  IF IP_C.C_PORT = WORD#00 THEN
    IP_C.C_PORT := PORT;
  END_IF;
  IF IP_C.C_IP=DWORD#00 AND IP_C.C_MODE<BYTE#4 THEN
    IP_C.C_IP := IP; 
  END_IF;

  NEW_CONNECTION := C_IP <> IP_C.C_IP OR C_MODE <> IP_C.C_MODE OR C_PORT <> IP_C.C_PORT;

  IF IP_C.C_ENABLE AND NOT C_READY AND NEW_CONNECTION THEN

    C_IP   := IP_C.C_IP; 
    C_MODE := IP_C.C_MODE;
    C_PORT := IP_C.C_PORT;

    CS := SEL_STRING((C_MODE AND BYTE#1) = BYTE#1,'','/UDP ');
    CS := CONCAT(CS,SEL_STRING(C_MODE<BYTE#2,'/PASSIVE','/ACTIVE'));
    CS := CONCAT(CS,' /PORT=');
    CS := CONCAT(CS,WORD_TO_STRING(C_PORT,'%u'));

    IF C_MODE<BYTE#4 THEN 
      IP4_TO_STRING(IP4:=C_IP); 
      CS := CONCAT(CS,' /IP=');
      CS := CONCAT(CS,IP4_TO_STRING.IP4_TO_STRING);
    END_IF;

    ERROR_TIME := MAX(UDINT#200,TIME_TO_UDINT2(TIME_OUT));
    IP_C.TIME_RESET := TRUE;   
  END_IF;

  C_ENABLE := IP_C.C_ENABLE AND NOT C_RECONNECT AND NOT NEW_CONNECTION AND IP_C.ERROR = DWORD#0;

  FB_IP_CONNECT.EN_C    := C_ENABLE;  
  FB_IP_CONNECT.PARTNER := CS;
  FB_IP_CONNECT(); 
  C_READY  := FB_IP_CONNECT.VALID;
  C_ERROR  := FB_IP_CONNECT.ERROR;
  C_STATUS := FB_IP_CONNECT.STATUS;
  C_ID     := FB_IP_CONNECT.ID;

  IF C_ENABLE THEN
    IF NOT C_ENABLE_OLD THEN
      DELAY_VALUE := UDINT#50; 
    END_IF;
  ELSE
    IF C_ENABLE_OLD THEN
      C_RECONNECT := FALSE;
      DELAY_VALUE := UDINT#50; 
    END_IF;
  END_IF;

  C_ENABLE_OLD := C_ENABLE;

  IF C_READY THEN
    IF NOT C_READY_OLD THEN
      IP_C.C_STATE := BYTE#254;
      DELAY_VALUE := UDINT#50;  
      IP_C.TIME_RESET := TRUE;  
    ELSE
      IP_C.C_STATE := BYTE#255;  
    END_IF;
  ELSE
    IF C_READY_OLD THEN
      IP_C.C_STATE := BYTE#1;
    IP_C.MAILBOX[1] := BYTE#0; 
    IP_C.MAILBOX[2] := BYTE#0; 
    IP_C.MAILBOX[3] := BYTE#0; 
      DELAY_VALUE := UDINT#50;  

      IF NOT NEW_CONNECTION THEN
        S_ACTIVE := FALSE;        
        S_BUF.SIZE := UINT#0;     
      END_IF;
    ELSE
      IP_C.C_STATE := BYTE#000; 
    END_IF;
  END_IF;

  C_READY_OLD := C_READY;
  C := 1; 
  IF S_BUF.SIZE > UINT#0 THEN
    IF C_READY AND C_ENABLE AND S_ACTIVE = FALSE AND IP_C.MAILBOX[2] = BYTE#0 THEN
      S_ACTIVE := TRUE; 
      S_TIME := tx; 
      R_TIME := tx;
      C := 0;
    END_IF;
  END_IF;

  FOR C2 := C TO 1 DO
    FB_IP_USEND.REQ    := S_ACTIVE AND C2=1;
    FB_IP_USEND.ID     := C_ID;
    FB_IP_USEND.R_ID   := '';
    FB_IP_USEND.SD_1   := S_BUF;
    FB_IP_USEND();
    S_DONE   := FB_IP_USEND.DONE;
    S_ERROR  := FB_IP_USEND.ERROR;
    S_STATUS := FB_IP_USEND.STATUS;
    S_BUF    := FB_IP_USEND.SD_1;
  END_FOR;

  IF S_DONE THEN    
      S_ACTIVE := FALSE;
      S_BUF.SIZE := UINT#0;
  END_IF;

  FB_IP_URCV.EN_R := C_READY AND NOT S_ACTIVE AND IP_C.MAILBOX[3] = BYTE#0; 
  FB_IP_URCV.ID   := C_ID;
  FB_IP_URCV.R_ID := '';
  FB_IP_URCV.RD_1 := R_BUF;
  FB_IP_URCV();
  R_NDR    := FB_IP_URCV.NDR;
  R_ERROR  := FB_IP_URCV.ERROR;
  R_STATUS := FB_IP_URCV.STATUS;
  R_BUF    := FB_IP_URCV.RD_1;

  IF R_NDR THEN
      R_TIME := TX;
      IP_C.MAILBOX[1] := USINT_TO_BYTE(BYTE_TO_USINT(IP_C.MAILBOX[1]) + USINT#1); 
      IF IP_C.MAILBOX[1] = BYTE#0 THEN IP_C.MAILBOX[1] := BYTE#1; END_IF;
  END_IF;

  IF IP_C.TIME_RESET THEN     
    IP_C.TIME_RESET := FALSE;
    C_RECONNECT_COUNT := 0;  
    C_TIME := tx;           
    S_TIME := tx;             
    R_TIME := tx;            

    ERROR_CON := BYTE#0;	
    ERROR_SND := BYTE#0;		
    ERROR_RCV := BYTE#0;	
  END_IF;

  IF IP_C.R_OBSERVE = FALSE OR s_active THEN
      R_TIME := tx;
  END_IF;

  C_RECONNECT := FALSE;

  IF ERROR_CON = BYTE#0 THEN
    IF C_ERROR THEN 
    IF C_STATUS = 16#31 THEN
      ERROR_CON := BYTE#253;
    ELSE
      ERROR_CON := INT_TO_BYTE(C_STATUS);
    END_IF;
    ELSIF TX - C_TIME > ERROR_TIME AND C_ENABLE AND NOT C_READY AND C_MODE < BYTE#2 THEN
      IF C_RECONNECT_COUNT >= 3 THEN
        ERROR_CON := BYTE#255;
      ELSE
        C_TIME := TX; 
        C_RECONNECT_COUNT := C_RECONNECT_COUNT + 1;
        C_RECONNECT := TRUE;
      END_IF;
    END_IF;
  END_IF;

  IF ERROR_SND = BYTE#0 THEN
    IF S_ERROR AND S_STATUS <> 16#65 THEN
      ERROR_SND := INT_TO_BYTE(S_STATUS);
    ELSIF TX - S_TIME > ERROR_TIME AND S_ACTIVE THEN 
      ERROR_SND := BYTE#255; 
    END_IF;
  END_IF;

  IF ERROR_RCV = BYTE#0 THEN
    IF R_ERROR AND (R_STATUS <> 16#33) AND (R_STATUS <> 16#31) AND (R_STATUS <> 16#65) THEN
      ERROR_RCV := INT_TO_BYTE(R_STATUS);
    ELSIF TX - R_TIME > ERROR_TIME AND C_READY AND IP_C.R_OBSERVE THEN
      ERROR_RCV := BYTE#255; 
    END_IF;
  END_IF;

  IP_C.ERROR := DWORD_OF_BYTE(ERROR_CON,ERROR_SND,ERROR_RCV,BYTE#0);

END_FUNCTION_BLOCK
